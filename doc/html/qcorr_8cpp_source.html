<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Qcorr: A Digital Image Correlation Program implemented in QT4: src/qcorr.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>src/qcorr.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &lt;QtGui&gt;</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="preprocessor">#include &quot;qcorr.h&quot;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &quot;globals.h&quot;</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 Qcorr::Qcorr(QWidget *parent)
<a name="l00009"></a>00009     : QMainWindow(parent)
<a name="l00010"></a>00010 {
<a name="l00011"></a>00011         setupUi(<span class="keyword">this</span>);
<a name="l00012"></a>00012 
<a name="l00013"></a>00013         setImageLabels();
<a name="l00014"></a>00014 
<a name="l00015"></a>00015    createActions();
<a name="l00016"></a>00016 
<a name="l00017"></a>00017    this-&gt;setWindowTitle(tr(<span class="stringliteral">&quot;QCorr&quot;</span>));
<a name="l00018"></a>00018    this-&gt;setCentralWidget(main_frame); <span class="comment">// Necessary for main frame to resize with main window</span>
<a name="l00019"></a>00019 <span class="comment">//   resize(500, 400);</span>
<a name="l00020"></a>00020 }
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 Qcorr::~Qcorr()
<a name="l00023"></a>00023 {
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 }
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="keywordtype">void</span> Qcorr::setImageLabels()
<a name="l00028"></a>00028 {
<a name="l00029"></a>00029 <span class="comment">//   m_leftImage_label = new QLabel(scrollAreaWidgetContents);</span>
<a name="l00030"></a>00030 <span class="comment">//   m_leftImage_label = new QLabel;</span>
<a name="l00031"></a>00031    m_leftImage_label = <span class="keyword">new</span> <a class="code" href="classImgLabel.html">ImgLabel</a>(<span class="keyword">this</span>);
<a name="l00032"></a>00032 <span class="comment">//   m_leftImage_label-&gt;setBackgroundRole(QPalette::Base);</span>
<a name="l00033"></a>00033    m_leftImage_label-&gt;setBackgroundRole(QPalette::Dark);
<a name="l00034"></a>00034    m_leftImage_label-&gt;setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Ignored);
<a name="l00035"></a>00035    m_leftImage_label-&gt;setScaledContents(<span class="keyword">true</span>);
<a name="l00036"></a>00036    m_leftImage_label-&gt;setMouseTracking(<span class="keyword">true</span>);
<a name="l00037"></a>00037 
<a name="l00038"></a>00038    leftImage_scrollArea-&gt;setWidget(m_leftImage_label);
<a name="l00039"></a>00039    leftImage_scrollArea-&gt;setBackgroundRole(QPalette::Dark);
<a name="l00040"></a>00040 
<a name="l00041"></a>00041    m_targetImage_label = <span class="keyword">new</span> <a class="code" href="classTargetImgLabel.html">TargetImgLabel</a>(<span class="keyword">this</span>);  <span class="comment">// Draw Right Image</span>
<a name="l00042"></a>00042 <span class="comment">//   rightImage_label-&gt;setBackgroundRole(QPalette::Base);</span>
<a name="l00043"></a>00043    m_targetImage_label-&gt;setBackgroundRole(QPalette::Dark);
<a name="l00044"></a>00044    m_targetImage_label-&gt;setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Ignored);
<a name="l00045"></a>00045    m_targetImage_label-&gt;setScaledContents(<span class="keyword">true</span>);
<a name="l00046"></a>00046 
<a name="l00047"></a>00047    rightImage_scrollArea-&gt;setWidget(m_targetImage_label);
<a name="l00048"></a>00048    rightImage_scrollArea-&gt;setBackgroundRole(QPalette::Dark);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050    <span class="comment">// BEGIN Status label configuration: vvvvvvvvv</span>
<a name="l00051"></a>00051    m_status_label = <span class="keyword">new</span> QLabel;
<a name="l00052"></a>00052    m_status_label-&gt;setAlignment(Qt::AlignLeft);
<a name="l00053"></a>00053    QFont font;
<a name="l00054"></a>00054    font.setFamily(QString::fromUtf8(<span class="stringliteral">&quot;Arial&quot;</span>));
<a name="l00055"></a>00055    m_status_label-&gt;setFont(font);
<a name="l00056"></a>00056 
<a name="l00057"></a>00057    QSizePolicy sizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
<a name="l00058"></a>00058    sizePolicy.setHorizontalStretch(0);
<a name="l00059"></a>00059    sizePolicy.setVerticalStretch(0);
<a name="l00060"></a>00060    m_status_label-&gt;setSizePolicy(sizePolicy);
<a name="l00061"></a>00061 
<a name="l00062"></a>00062    statusbar-&gt;addWidget(m_status_label);
<a name="l00063"></a>00063    <span class="comment">// END Status label configuration ^^^^^^</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065    corr_pushButton-&gt;setEnabled(<span class="keyword">false</span>); <span class="comment">// This button should be initially disabled because there&apos;s no target image to correlate to</span>
<a name="l00066"></a>00066 
<a name="l00067"></a>00067    <span class="comment">// Create Correlation Method Dialog, which is initially hidden</span>
<a name="l00068"></a>00068    m_corrMethodDialog = <span class="keyword">new</span> <a class="code" href="classCorrMethod.html">CorrMethod</a>(<span class="keyword">this</span>);
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keywordtype">void</span> Qcorr::createActions()
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074    connect(quit_pushButton, SIGNAL(clicked()), <span class="keyword">this</span>, SLOT(close()));
<a name="l00075"></a>00075    connect(leftBrowse_pushButton, SIGNAL(clicked()), <span class="keyword">this</span>, SLOT(browseLeftImage()));
<a name="l00076"></a>00076    connect(rightBrowse_pushButton, SIGNAL(clicked()), <span class="keyword">this</span>, SLOT(browseRightImage()));
<a name="l00077"></a>00077    connect(corr_pushButton, SIGNAL(clicked()), <span class="keyword">this</span>, SLOT(correlate()));
<a name="l00078"></a>00078 
<a name="l00079"></a>00079    action_Quit-&gt;setShortcut(tr(<span class="stringliteral">&quot;Ctrl+Q&quot;</span>));
<a name="l00080"></a>00080    connect(action_Quit, SIGNAL(triggered()), <span class="keyword">this</span>, SLOT(close()));
<a name="l00081"></a>00081 
<a name="l00082"></a>00082    action_Correlation_Map-&gt;setCheckable(<span class="keyword">true</span>);
<a name="l00083"></a>00083    action_Correlation_Map-&gt;setEnabled(<span class="keyword">false</span>);
<a name="l00084"></a>00084    connect(action_Correlation_Map, SIGNAL(triggered()), <span class="keyword">this</span>, SLOT(viewCorrMap()));
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="comment">// begin Q_SLOTS vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv</span>
<a name="l00088"></a>00088 <span class="keywordtype">void</span> Qcorr::browseLeftImage()
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090    <span class="keywordflow">if</span> (leftImage_lineEdit-&gt;text().isEmpty())
<a name="l00091"></a>00091       initialName =  rightImage_lineEdit-&gt;text(); <span class="comment">// observes the path on the other panel</span>
<a name="l00092"></a>00092    <span class="keywordflow">else</span>
<a name="l00093"></a>00093       initialName = leftImage_lineEdit-&gt;text(); <span class="comment">// observes its own path</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 
<a name="l00096"></a>00096    <span class="keywordflow">if</span> (initialName.isEmpty())
<a name="l00097"></a>00097       initialName = QDir::homePath();
<a name="l00098"></a>00098 
<a name="l00099"></a>00099    QString fileName = QFileDialog::getOpenFileName(<span class="keyword">this</span>, tr(<span class="stringliteral">&quot;Choose File&quot;</span>),
<a name="l00100"></a>00100          initialName);
<a name="l00101"></a>00101    fileName = QDir::toNativeSeparators(fileName);
<a name="l00102"></a>00102 
<a name="l00103"></a>00103    <span class="keywordflow">if</span> (!fileName.isEmpty()) {
<a name="l00104"></a>00104 
<a name="l00105"></a>00105       leftImage_lineEdit-&gt;setText(fileName);
<a name="l00106"></a>00106       m_leftImage = <span class="keyword">new</span> QImage(fileName);
<a name="l00107"></a>00107 
<a name="l00108"></a>00108       <span class="keywordflow">if</span> (m_leftImage-&gt;isNull()) {
<a name="l00109"></a>00109          QMessageBox::information(<span class="keyword">this</span>, tr(<span class="stringliteral">&quot;QCorr&quot;</span>),
<a name="l00110"></a>00110                tr(<span class="stringliteral">&quot;Cannot load %1.&quot;</span>).arg(fileName));
<a name="l00111"></a>00111          <span class="keywordflow">return</span>;
<a name="l00112"></a>00112       }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114       this-&gt;displayImageLabel(m_leftImage, m_leftImage_label);   <span class="comment">// Draw Left Image</span>
<a name="l00115"></a>00115 
<a name="l00116"></a>00116       m_leftImage_label-&gt;setCursor(QCursor(Qt::CrossCursor));
<a name="l00117"></a>00117       m_leftImage_label-&gt;setMouseTracking(<span class="keyword">true</span>);
<a name="l00118"></a>00118       m_leftImage_label-&gt;setFocusPolicy(Qt::ClickFocus);
<a name="l00119"></a>00119    }
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keywordtype">void</span> Qcorr::browseRightImage()
<a name="l00123"></a>00123 {
<a name="l00124"></a>00124    <span class="keywordflow">if</span> (rightImage_lineEdit-&gt;text().isEmpty())
<a name="l00125"></a>00125       initialName =  leftImage_lineEdit-&gt;text(); <span class="comment">// observes the path on the other panel</span>
<a name="l00126"></a>00126    <span class="keywordflow">else</span>
<a name="l00127"></a>00127       initialName = rightImage_lineEdit-&gt;text(); <span class="comment">// observes its own path</span>
<a name="l00128"></a>00128 
<a name="l00129"></a>00129    <span class="keywordflow">if</span> (initialName.isEmpty())
<a name="l00130"></a>00130       initialName = QDir::homePath();
<a name="l00131"></a>00131 
<a name="l00132"></a>00132    QString fileName = QFileDialog::getOpenFileName(<span class="keyword">this</span>, tr(<span class="stringliteral">&quot;Choose File&quot;</span>),
<a name="l00133"></a>00133          initialName);
<a name="l00134"></a>00134    fileName = QDir::toNativeSeparators(fileName);
<a name="l00135"></a>00135 
<a name="l00136"></a>00136    <span class="keywordflow">if</span> (!fileName.isEmpty()) {
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 
<a name="l00139"></a>00139       rightImage_lineEdit-&gt;setText(fileName);
<a name="l00140"></a>00140       m_rightImage = <span class="keyword">new</span> QImage(fileName);
<a name="l00141"></a>00141 
<a name="l00142"></a>00142       <span class="keywordflow">if</span> (m_rightImage-&gt;isNull()) {
<a name="l00143"></a>00143          QMessageBox::information(<span class="keyword">this</span>, tr(<span class="stringliteral">&quot;QCorr&quot;</span>),
<a name="l00144"></a>00144                tr(<span class="stringliteral">&quot;Cannot load %1.&quot;</span>).arg(fileName));
<a name="l00145"></a>00145          <span class="keywordflow">return</span>;
<a name="l00146"></a>00146       }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148      m_targetImage_label-&gt;setImage(*m_rightImage);
<a name="l00149"></a>00149 
<a name="l00150"></a>00150       <span class="comment">// CARLOS: just for testing:</span>
<a name="l00151"></a>00151       <span class="comment">// To verify if the data has been converted to grayscale,</span>
<a name="l00152"></a>00152       <span class="comment">// and that QImage&apos;s bits() function uses only the data pixels without any formatting headers</span>
<a name="l00153"></a>00153 <span class="comment">//      m_grayRightImage = new QImage(convertToGrayScale(m_rightImage));</span>
<a name="l00154"></a>00154 <span class="comment">//</span>
<a name="l00155"></a>00155 <span class="comment">//      std::cout &lt;&lt; &quot;Original Image depth: &quot; &lt;&lt;  m_rightImage-&gt;depth() &lt;&lt; &quot;-bit&quot; &lt;&lt; std::endl;</span>
<a name="l00156"></a>00156 <span class="comment">//      std::cout &lt;&lt; &quot;Gray Scale Image depth: &quot; &lt;&lt;  m_grayRightImage-&gt;depth() &lt;&lt; &quot;-bit&quot; &lt;&lt; std::endl;</span>
<a name="l00157"></a>00157 <span class="comment">//      std::cout &lt;&lt; &quot;Number of Bytes: &quot; &lt;&lt; m_grayRightImage-&gt;numBytes() &lt;&lt; &quot;\tNumber of Colors: &quot; &lt;&lt; m_grayRightImage-&gt;numColors() &lt;&lt; std::endl;</span>
<a name="l00158"></a>00158 <span class="comment">//</span>
<a name="l00159"></a>00159 <span class="comment">//      m_targetImage_label-&gt;setImage(*m_grayRightImage);</span>
<a name="l00160"></a>00160       <span class="comment">//</span>
<a name="l00161"></a>00161       <span class="comment">//        if(!fileDumpQImage(fileName + &quot;.txt&quot;))</span>
<a name="l00162"></a>00162       <span class="comment">//            return;</span>
<a name="l00163"></a>00163 
<a name="l00164"></a>00164       update();
<a name="l00165"></a>00165 
<a name="l00166"></a>00166       corr_pushButton-&gt;setEnabled(<span class="keyword">true</span>); <span class="comment">// Now, this button can be enabled because a target image exists to correlate to</span>
<a name="l00167"></a>00167    }
<a name="l00168"></a>00168 }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="keywordtype">void</span> Qcorr::viewCorrMap()
<a name="l00171"></a>00171 {
<a name="l00172"></a>00172    <span class="keywordflow">if</span>(action_Correlation_Map-&gt;isChecked())
<a name="l00173"></a>00173       {
<a name="l00174"></a>00174       m_targetImage_label-&gt;overlayImage(*m_corrMapImage);
<a name="l00175"></a>00175       }
<a name="l00176"></a>00176    <span class="keywordflow">else</span>
<a name="l00177"></a>00177       {
<a name="l00178"></a>00178       m_targetImage_label-&gt;setImage(*m_rightImage);
<a name="l00179"></a>00179       }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="keywordtype">void</span> Qcorr::correlate()
<a name="l00184"></a>00184 {
<a name="l00185"></a>00185    <span class="keywordflow">if</span>(m_leftImage_label-&gt;m_rubberBand-&gt;isVisible())
<a name="l00186"></a>00186       {
<a name="l00187"></a>00187       m_templateImage = <span class="keyword">new</span> QImage(m_leftImage-&gt;copy(m_leftImage_label-&gt;m_rubberBand-&gt;geometry()));
<a name="l00188"></a>00188 
<a name="l00189"></a>00189       m_templateSize = m_templateImage-&gt;size();
<a name="l00190"></a>00190 
<a name="l00191"></a>00191       m_corrMethodDialog-&gt;exec();   <span class="comment">// Making sure that this dialog behaves modally</span>
<a name="l00192"></a>00192                                     <span class="comment">// Otherwise, a dialog is not modal if it&apos;s invoked using show()</span>
<a name="l00193"></a>00193 
<a name="l00194"></a>00194       <span class="keywordflow">if</span>(m_corrMethodDialog-&gt;<a class="code" href="classCorrMethod.html#a3eeafdd901560c1fa92be75d4ed58872" title="Retrieve the selected method to be used in the correlation process.">getMethod</a>() == N0_CORR_METHOD)
<a name="l00195"></a>00195          {
<a name="l00196"></a>00196          <span class="keywordflow">if</span>(!m_leftImage_label-&gt;m_rubberBand-&gt;isVisible())
<a name="l00197"></a>00197             m_targetImage_label-&gt;eraseEnclosedMatch();
<a name="l00198"></a>00198          }
<a name="l00199"></a>00199       <span class="keywordflow">else</span>
<a name="l00200"></a>00200          {
<a name="l00201"></a>00201 <span class="comment">//         this-&gt;corrResults_label-&gt;setText( &quot;Method: &quot; + QString::number(m_corrMethodDialog-&gt;getMethod()));</span>
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 
<a name="l00204"></a>00204          <span class="comment">// Target Image dimensions:</span>
<a name="l00205"></a>00205          <span class="keywordtype">int</span> wI = m_rightImage-&gt;width();
<a name="l00206"></a>00206          <span class="keywordtype">int</span> hI = m_rightImage-&gt;height();
<a name="l00207"></a>00207          <span class="keywordtype">int</span> depthI = m_rightImage-&gt;depth();
<a name="l00208"></a>00208 
<a name="l00209"></a>00209          <span class="comment">// Template Image dimensions:</span>
<a name="l00210"></a>00210          <span class="keywordtype">int</span> wT = m_templateImage-&gt;width();
<a name="l00211"></a>00211          <span class="keywordtype">int</span> hT = m_templateImage-&gt;height();
<a name="l00212"></a>00212          <span class="keywordtype">int</span> depthT = m_templateImage-&gt;depth();
<a name="l00213"></a>00213 
<a name="l00214"></a>00214             <span class="keywordtype">float</span> fCorrLevel = <a class="code" href="classQcorr.html#aa867dbbe79fe720631216eec154a12e2" title="Cross-correlation of target image with template image.">findCorrelation</a>( m_rightImage-&gt;bits(), wI, hI, depthI,
<a name="l00215"></a>00215                                                 m_templateImage-&gt;bits(), wT, hT, depthT,
<a name="l00216"></a>00216                                                 m_nXoffset, m_nYoffset,
<a name="l00217"></a>00217                                                 m_corrMethodDialog-&gt;<a class="code" href="classCorrMethod.html#a3eeafdd901560c1fa92be75d4ed58872" title="Retrieve the selected method to be used in the correlation process.">getMethod</a>(),
<a name="l00218"></a>00218                                                 <span class="keyword">false</span>);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 
<a name="l00221"></a>00221             <span class="comment">// CARLOS: just for testing:</span>
<a name="l00222"></a>00222    <span class="comment">//         m_targetImage_label-&gt;setImage(*m_templateImage);   // Draw Template on Right Label</span>
<a name="l00223"></a>00223    <span class="comment">//</span>
<a name="l00224"></a>00224    <span class="comment">//         this-&gt;m_status_label-&gt;setText(</span>
<a name="l00225"></a>00225    <span class="comment">//               &quot;Finding Correlation for the &lt;b&gt;(&quot; + QString::number(m_templateImage-&gt;width()) + &quot;x&quot;</span>
<a name="l00226"></a>00226    <span class="comment">//               + QString::number(m_templateImage-&gt;height()) + &quot;)px &lt;/b&gt;Template ...&quot; );</span>
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 
<a name="l00229"></a>00229             <span class="comment">// TO DO: Validate the results before allowing to draw the enclosing rectangle around the match</span>
<a name="l00230"></a>00230             <span class="keywordflow">if</span>(fCorrLevel &gt;= 0.0)
<a name="l00231"></a>00231                {
<a name="l00232"></a>00232                m_targetImage_label-&gt;setImage(*m_rightImage);   <span class="comment">// reset Image</span>
<a name="l00233"></a>00233 
<a name="l00234"></a>00234                <a class="code" href="classQcorr.html#a8a7f00160ae46441cef038149cf28bdc" title="upper-left corner point where the correlation match was found">m_matchingPoint</a>.setX(m_nXoffset);
<a name="l00235"></a>00235                <a class="code" href="classQcorr.html#a8a7f00160ae46441cef038149cf28bdc" title="upper-left corner point where the correlation match was found">m_matchingPoint</a>.setY(m_nYoffset);
<a name="l00236"></a>00236                m_targetImage_label-&gt;drawEnclosedMatch(<a class="code" href="classQcorr.html#a8a7f00160ae46441cef038149cf28bdc" title="upper-left corner point where the correlation match was found">m_matchingPoint</a>, m_templateSize);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238                this-&gt;corrResults_label-&gt;setText( <span class="stringliteral">&quot;Correlation level: &quot;</span> + QString::number(fCorrLevel)
<a name="l00239"></a>00239                                                 + <span class="stringliteral">&quot;\tat &lt;b&gt;(&quot;</span> + QString::number(m_nXoffset) + <span class="stringliteral">&quot;, &quot;</span>
<a name="l00240"></a>00240                                                 + QString::number(m_nYoffset) + <span class="stringliteral">&quot;)px&lt;/b&gt;&quot;</span>
<a name="l00241"></a>00241                                                 );
<a name="l00242"></a>00242    <span class="comment">//            m_targetImage_label-&gt;setImage(*m_corrMapImage);</span>
<a name="l00243"></a>00243 
<a name="l00244"></a>00244                action_Correlation_Map-&gt;setEnabled(<span class="keyword">true</span>);
<a name="l00245"></a>00245                emit this-&gt;viewCorrMap();  <span class="comment">// emit this signal so it refreshes the correlation map automatically</span>
<a name="l00246"></a>00246 
<a name="l00247"></a>00247                }
<a name="l00248"></a>00248             <span class="keywordflow">else</span>
<a name="l00249"></a>00249                m_targetImage_label-&gt;eraseEnclosedMatch();
<a name="l00250"></a>00250 
<a name="l00251"></a>00251          }
<a name="l00252"></a>00252       }
<a name="l00253"></a>00253    <span class="keywordflow">else</span>
<a name="l00254"></a>00254       {
<a name="l00255"></a>00255       this-&gt;m_status_label-&gt;setText(<span class="stringliteral">&quot;There is No template!&quot;</span>);
<a name="l00256"></a>00256       this-&gt;corrResults_label-&gt;clear();
<a name="l00257"></a>00257       }
<a name="l00258"></a>00258 }
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 <span class="comment">// end Q_SLOTS ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<a name="l00261"></a>00261 
<a name="l00262"></a><a class="code" href="classQcorr.html#aa867dbbe79fe720631216eec154a12e2">00262</a> <span class="keywordtype">float</span> <a class="code" href="classQcorr.html#aa867dbbe79fe720631216eec154a12e2" title="Cross-correlation of target image with template image.">Qcorr::findCorrelation</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * imgTarget, <span class="keyword">const</span> <span class="keywordtype">int</span> nWI, <span class="keyword">const</span> <span class="keywordtype">int</span> nHI, <span class="keyword">const</span> <span class="keywordtype">int</span> nDepthI,
<a name="l00263"></a>00263       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * imgTemplate, <span class="keyword">const</span> <span class="keywordtype">int</span> nWT, <span class="keyword">const</span> <span class="keywordtype">int</span> nHT, <span class="keyword">const</span> <span class="keywordtype">int</span> nDepthT, <span class="keywordtype">int</span> &amp;rnDx, <span class="keywordtype">int</span> &amp;rnDy, <span class="keywordtype">int</span> nMethod, <span class="keywordtype">bool</span> bMultires)
<a name="l00264"></a>00264 {
<a name="l00265"></a>00265    <span class="comment">// Helped to test that the bits dumped by QImage&apos;s bits() function</span>
<a name="l00266"></a>00266    <span class="comment">// is the actual data (pixels) of the image without any header.</span>
<a name="l00267"></a>00267    <span class="comment">// ...just pure pixel data!</span>
<a name="l00268"></a>00268 <span class="comment">//   QFile file(&quot;test&quot;);  // in the executable application&apos;s folder</span>
<a name="l00269"></a>00269 <span class="comment">//   if (!file.open(QIODevice::WriteOnly)) {</span>
<a name="l00270"></a>00270 <span class="comment">//      QMessageBox::warning(this, tr(&quot;QCorr Image&quot;),</span>
<a name="l00271"></a>00271 <span class="comment">//            tr(&quot;Cannot write file %1:\n%2.&quot;)</span>
<a name="l00272"></a>00272 <span class="comment">//            .arg(file.fileName())</span>
<a name="l00273"></a>00273 <span class="comment">//            .arg(file.errorString()));</span>
<a name="l00274"></a>00274 <span class="comment">//      return false;</span>
<a name="l00275"></a>00275 <span class="comment">//   }</span>
<a name="l00276"></a>00276 <span class="comment">//   QDataStream out(&amp;file);</span>
<a name="l00277"></a>00277 <span class="comment">//   out.setVersion(QDataStream::Qt_4_5);</span>
<a name="l00278"></a>00278 <span class="comment">//</span>
<a name="l00279"></a>00279 <span class="comment">//   QApplication::setOverrideCursor(Qt::WaitCursor);</span>
<a name="l00280"></a>00280 <span class="comment">//</span>
<a name="l00281"></a>00281 <span class="comment">//   // Helped to test that the bits dumped by QImage&apos;s bits() function</span>
<a name="l00282"></a>00282 <span class="comment">//   // is the actual data (pixels) of the image without any header.</span>
<a name="l00283"></a>00283 <span class="comment">//   // ...just pure pixel data!</span>
<a name="l00285"></a>00285 <span class="comment"></span><span class="comment">//</span>
<a name="l00286"></a>00286 <span class="comment">//   int mysalt = 0;  // just to see if the image has extra bytes that might be missing</span>
<a name="l00287"></a>00287 <span class="comment">//   int imgBytes = m_grayRightImage-&gt;numBytes() + mysalt;</span>
<a name="l00288"></a>00288 <span class="comment">//</span>
<a name="l00289"></a>00289 <span class="comment">//   for (int byteN = 0; byteN &lt; imgBytes; ++byteN) {</span>
<a name="l00291"></a>00291 <span class="comment"></span><span class="comment">//      out &lt;&lt; quint8(imgTarget[byteN]);</span>
<a name="l00292"></a>00292 <span class="comment">//   }</span>
<a name="l00293"></a>00293 
<a name="l00294"></a>00294    QApplication::setOverrideCursor(Qt::WaitCursor);
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 
<a name="l00297"></a>00297    <span class="keywordtype">int</span> i, j, k, n, x, y, total;
<a name="l00298"></a>00298    <span class="keywordtype">int</span> nXTraverse, nYTraverse, mxlevel, lowres;
<a name="l00299"></a>00299    <span class="keywordtype">int</span> nPixelNumber;
<a name="l00300"></a>00300    <span class="keywordtype">float</span> fSumTop, fSumBottom, fDiff, fCorr;
<a name="l00301"></a>00301    <span class="keywordtype">float</span> fAverage, fTemplatePower, fTargetPower;
<a name="l00302"></a>00302    <span class="keywordtype">float</span> *pfImgTarget, *pfImgTemplate, mag, *pfTraversedTarget, *pfTraversingTemplate;
<a name="l00303"></a>00303    <span class="keywordtype">float</span> fMin, fMax;
<a name="l00304"></a>00304    <span class="keywordtype">double</span> dXSize, dYSize;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="comment">//   QImage II1, II2, Ifft1, Ifft2, Iblur, pyramidTarget[8], pyramidTemplate[8];</span>
<a name="l00308"></a>00308    QImage Ifft1, Ifft2, Iblur, pyramidTarget[8], pyramidTemplate[8];
<a name="l00309"></a>00309 
<a name="l00310"></a>00310    <span class="comment">// Images&apos; size:</span>
<a name="l00311"></a>00311    <span class="keywordtype">int</span> sizeI = nWI*nHI;
<a name="l00312"></a>00312    <span class="keywordtype">int</span> sizeT = nWT*nHT;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314    <span class="comment">/* error checking: size of pfTraversedTarget I1 must be &gt;= than pfTraversingTemplate I2 */</span>
<a name="l00315"></a>00315    <span class="keywordflow">if</span> ((nWT &gt; nWI) || (nHT &gt; nHI))
<a name="l00316"></a>00316       {
<a name="l00317"></a>00317       QMessageBox::warning(<span class="keyword">this</span>, tr(<span class="stringliteral">&quot;QCorr&quot;</span>), tr(<span class="stringliteral">&quot;Traversed Target Image is smaller than Traversing Template\n&quot;</span>));
<a name="l00318"></a>00318       QApplication::restoreOverrideCursor();
<a name="l00319"></a>00319       <span class="keywordflow">return</span> 0.;
<a name="l00320"></a>00320       }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322    <span class="comment">// cast images to an 8-bit channel (convert them to gray-scale images) as floats:</span>
<a name="l00323"></a>00323    <span class="keywordtype">float</span> *afImgTarget = <a class="code" href="classQcorr.html#ad1b26ace597c0c4a0f64a0bd9576d4fc" title="Cast images to an 8-bit gray-scale channel of type float.">convertToGrayScaleFloat</a>(imgTarget, sizeI, nDepthI);
<a name="l00324"></a>00324 
<a name="l00325"></a>00325    <span class="keywordtype">float</span> *afImgTemplate = <a class="code" href="classQcorr.html#ad1b26ace597c0c4a0f64a0bd9576d4fc" title="Cast images to an 8-bit gray-scale channel of type float.">convertToGrayScaleFloat</a>(imgTemplate, sizeT, nDepthT);
<a name="l00326"></a>00326 
<a name="l00327"></a>00327    <span class="comment">/*</span>
<a name="l00328"></a>00328 <span class="comment">    * create pfTraversedTarget and pfTraversingTemplate pyramids with original images at base;</span>
<a name="l00329"></a>00329 <span class="comment">    * if no multiresolution is used, pyramids consist of only one level.</span>
<a name="l00330"></a>00330 <span class="comment">    */</span>
<a name="l00331"></a>00331 <span class="comment">//   pyramidTarget[0] = *m_grayRightImage; // base: original traversed target</span>
<a name="l00332"></a>00332 <span class="comment">//   pyramidTemplate[0] = *m_templateImage; // base: original traversing template</span>
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 <span class="comment">// CARLOS: needs review from this point on... (and perhaps above, also) vvvvvvvvvvvvvv</span>
<a name="l00335"></a>00335 
<a name="l00336"></a>00336    <span class="keywordflow">if</span> (bMultires)
<a name="l00337"></a>00337       {
<a name="l00338"></a>00338          <span class="comment">/* set lowest resolution for pyramidTarget (empirically tested) */</span>
<a name="l00339"></a>00339          <span class="keywordflow">switch</span> (nMethod)
<a name="l00340"></a>00340             {
<a name="l00341"></a>00341             <span class="keywordflow">case</span> CROSS_CORR:
<a name="l00342"></a>00342             <span class="keywordflow">case</span> SUM_SQ_DIFF:
<a name="l00343"></a>00343                lowres = 64;
<a name="l00344"></a>00344                <span class="keywordflow">break</span>;
<a name="l00345"></a>00345             <span class="keywordflow">case</span> CORR_COEFF:
<a name="l00346"></a>00346                lowres = 128;
<a name="l00347"></a>00347                <span class="keywordflow">break</span>;
<a name="l00348"></a>00348 <span class="comment">//            case PHASE_CORR:</span>
<a name="l00349"></a>00349 <span class="comment">//               lowres = MAX(nWI, nHI); /* disable bMultires */</span>
<a name="l00350"></a>00350 <span class="comment">//               break;</span>
<a name="l00351"></a>00351             }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353          <span class="comment">/* update lowres if pyramidTemplate will become too small  */</span>
<a name="l00354"></a>00354          <span class="keywordflow">for</span> (k = 1; (nWI &gt;&gt; k) &gt;= lowres &amp;&amp; (nHI &gt;&gt; k) &gt;= lowres; k++)
<a name="l00355"></a>00355             ;
<a name="l00356"></a>00356          <span class="keywordflow">for</span> (k--; (nWT &gt;&gt; k) &lt; 4 || (nHT &gt;&gt; k) &lt; 4; k--)
<a name="l00357"></a>00357             lowres *= 2;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359          <span class="comment">/* compute lower-res versions for remaining pyramid levels */</span>
<a name="l00360"></a>00360          <span class="keywordflow">for</span> (k = 1; (nWI &gt;&gt; k) &gt;= lowres &amp;&amp; (nHI &gt;&gt; k) &gt;= lowres; k++)
<a name="l00361"></a>00361             {
<a name="l00362"></a>00362 <span class="comment">//               pyramidTarget[k] = m_grayRightImage-&gt;scaled(nWI, nHI,)</span>
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="comment">//               pyramidTarget[k] = NEWIMAGE;</span>
<a name="l00366"></a>00366 <span class="comment">//               pyramidTemplate[k] = NEWIMAGE;</span>
<a name="l00368"></a>00368 <span class="comment"></span><span class="comment">//               // CARLOS: The resize must be done with a function (Perhaps, OpenCV)</span>
<a name="l00369"></a>00369 <span class="comment">//               IP_resize(pyramidTarget[k - 1], nWI &gt;&gt; k, nHI &gt;&gt; k, TRIANGLE, pyramidTarget[k]);</span>
<a name="l00370"></a>00370 <span class="comment">//               IP_resize(pyramidTemplate[k - 1], nWT &gt;&gt; k, nHT &gt;&gt; k, TRIANGLE,</span>
<a name="l00371"></a>00371 <span class="comment">//                     pyramidTemplate[k]);</span>
<a name="l00372"></a>00372             }
<a name="l00373"></a>00373          mxlevel = k - 1;
<a name="l00374"></a>00374       }
<a name="l00375"></a>00375    <span class="keywordflow">else</span>
<a name="l00376"></a>00376       mxlevel = 0;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378    <span class="comment">// CARLOS: changed/fixed the following relation (it was omitting the last pixel on the edge)</span>
<a name="l00379"></a>00379 <span class="comment">//   nXTraverse = (nWI - nWT + 1) &gt;&gt; mxlevel;  // &gt;&gt; means: shift bit (divide by 2*mxlevel times)</span>
<a name="l00380"></a>00380 <span class="comment">//   nYTraverse = (nHI - nHT + 1) &gt;&gt; mxlevel;</span>
<a name="l00381"></a>00381    nXTraverse = (nWI - nWT) &gt;&gt; mxlevel;  <span class="comment">// &gt;&gt; means: shift bit (divide by 2*mxlevel times)</span>
<a name="l00382"></a>00382    nYTraverse = (nHI - nHT) &gt;&gt; mxlevel;
<a name="l00383"></a>00383 
<a name="l00384"></a>00384    <span class="comment">// ---------------------------------------------</span>
<a name="l00385"></a>00385    <span class="comment">// To be used to display a brightness map based on correlation values at each evaluated pixel</span>
<a name="l00386"></a>00386    m_corrMapImage = <span class="keyword">new</span> QImage(nXTraverse+1, nYTraverse+1 , QImage::Format_Indexed8);
<a name="l00387"></a>00387    QVector&lt;QRgb&gt; colorTab(256);  <span class="comment">// for an 8-bit scale color table</span>
<a name="l00388"></a>00388    <span class="keywordflow">for</span>(i=0; i&lt;= 255; i++)
<a name="l00389"></a>00389       {
<a name="l00390"></a>00390          colorTab[i] = qRgb(i,i,i); <span class="comment">// For a gray-scale color table</span>
<a name="l00391"></a>00391       }
<a name="l00392"></a>00392    <span class="comment">// If the image&apos;s format is either monochrome or 8-bit, the given index_or_rgb value must be an index in the image&apos;s color table</span>
<a name="l00393"></a>00393    m_corrMapImage-&gt;setColorTable(colorTab);
<a name="l00394"></a>00394 
<a name="l00395"></a>00395    <span class="keywordtype">float</span> *afCorrValues = <span class="keyword">new</span> <span class="keywordtype">float</span>[(nXTraverse+1) * (nYTraverse+1)]; <span class="comment">// Array to save results of each correlation operation at certain pixel</span>
<a name="l00396"></a>00396                                                                      <span class="comment">// Array size is correct based on the number of correlations to be performed on the target</span>
<a name="l00397"></a>00397    <span class="keywordtype">int</span> nCorrCounter = 0;
<a name="l00398"></a>00398    uint nValue;    <span class="comment">// to paint the pixels of the correlation map image</span>
<a name="l00399"></a>00399    <span class="comment">// ---------------------------------------------</span>
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 
<a name="l00403"></a>00403    <span class="comment">/* multiresolution correlation: use results of lower-res correlation</span>
<a name="l00404"></a>00404 <span class="comment">    * (at the top of the pyramid) to narrow the search in the higher-res</span>
<a name="l00405"></a>00405 <span class="comment">    * correlation (towards the base of the pyramid).</span>
<a name="l00406"></a>00406 <span class="comment">    */</span>
<a name="l00407"></a>00407    <span class="keywordflow">for</span> (n = mxlevel; n &gt;= 0; n--)
<a name="l00408"></a>00408       {
<a name="l00409"></a>00409 <span class="comment">//         /* init vars based on pyramid at level n */</span>
<a name="l00410"></a>00410 <span class="comment">//         nWI = pyramidTarget[n]-&gt;width;</span>
<a name="l00411"></a>00411 <span class="comment">//         nHI = pyramidTarget[n]-&gt;height;</span>
<a name="l00412"></a>00412 <span class="comment">//         nWT = pyramidTemplate[n]-&gt;width;</span>
<a name="l00413"></a>00413 <span class="comment">//         nHT = pyramidTemplate[n]-&gt;height;</span>
<a name="l00414"></a>00414 
<a name="l00415"></a>00415          <span class="comment">/* pointers to pfTraversedTarget and pfTraversingTemplate data */</span>
<a name="l00416"></a>00416 <span class="comment">//         pfImgTarget = (float *) pyramidTarget[n]-&gt;buf[0]; /* pfTraversedTarget    ptr */</span>
<a name="l00417"></a>00417 <span class="comment">//         pfImgTemplate = (float *) pyramidTemplate[n]-&gt;buf[0]; /* pfTraversingTemplate ptr */</span>
<a name="l00418"></a>00418          pfImgTarget = afImgTarget; <span class="comment">//[0]; /* pfTraversedTarget    ptr */</span>
<a name="l00419"></a>00419          pfImgTemplate = afImgTemplate; <span class="comment">//[0]; /* pfTraversingTemplate ptr */</span>
<a name="l00420"></a>00420 
<a name="l00421"></a>00421          <span class="comment">/* init fMin and fMax */</span>
<a name="l00422"></a>00422          fMin = 10000000.;
<a name="l00423"></a>00423          fMax = 0.;
<a name="l00424"></a>00424 
<a name="l00425"></a>00425          <span class="keywordflow">switch</span> (nMethod)
<a name="l00426"></a>00426             {
<a name="l00427"></a>00427             <span class="keywordflow">case</span> CROSS_CORR:
<a name="l00428"></a>00428                <span class="comment">/*  CROSS_CORR (cross correlation):</span>
<a name="l00429"></a>00429 <span class="comment">                *             C(u,v) = sum of {T(x,y) * I(x-u,y-v)}</span>
<a name="l00430"></a>00430 <span class="comment">                *                      --------------------------------</span>
<a name="l00431"></a>00431 <span class="comment">                *                      sqrt{ sum of {I(x-u,y-v)^2}}</span>
<a name="l00432"></a>00432 <span class="comment">                *     Levels:</span>
<a name="l00433"></a>00433 <span class="comment">                *             C = 1 Perfect Match</span>
<a name="l00434"></a>00434 <span class="comment">                *             0 &lt; C &lt; 1: Some Match (closer to 1 is higher)</span>
<a name="l00435"></a>00435 <span class="comment">                *             C = 0: No Match       *</span>
<a name="l00436"></a>00436 <span class="comment">                */</span>
<a name="l00437"></a>00437 
<a name="l00438"></a>00438                <span class="comment">// slide Template across the Target (pixel-by-pixel)</span>
<a name="l00439"></a>00439                <span class="keywordflow">for</span> (y = 0; y &lt;= nYTraverse; y++) <span class="comment">// Traverses the height until the template&apos;s bottom is sitting on the bottom edge of the target</span>
<a name="l00440"></a>00440                   { <span class="comment">// visit rows</span>
<a name="l00441"></a>00441                      <span class="keywordflow">for</span> (x = 0; x &lt;= nXTraverse; x++)    <span class="comment">// Traverses the width until the template&apos;s right edge is on the right edge of the target</span>
<a name="l00442"></a>00442                         { <span class="comment">// visit columns</span>
<a name="l00443"></a>00443                            fSumTop = fSumBottom = 0;  <span class="comment">// Clear sums to 0 for each Template-Target comparison</span>
<a name="l00444"></a>00444 
<a name="l00445"></a>00445                            nPixelNumber = (y * nWI) + x;
<a name="l00446"></a>00446                            pfTraversedTarget = pfImgTarget + nPixelNumber; <span class="comment">// Points to current position in target float array</span>
<a name="l00447"></a>00447                            pfTraversingTemplate = pfImgTemplate;  <span class="comment">// Always begins pointing to upper-left corner of template float array</span>
<a name="l00448"></a>00448 
<a name="l00449"></a>00449                            <span class="comment">// pixel-by-pixel comparison loops:</span>
<a name="l00450"></a>00450                            <span class="comment">// Comparing the Traversing Image&apos;s region (of Template Size) to the Template itself</span>
<a name="l00451"></a>00451                            <span class="keywordflow">for</span> (i = 0; i &lt; nHT; i++)
<a name="l00452"></a>00452                               { <span class="comment">// Similar to convolution</span>
<a name="l00453"></a>00453                                  <span class="keywordflow">for</span> (j = 0; j &lt; nWT; j++)
<a name="l00454"></a>00454                                     {
<a name="l00455"></a>00455                                        fSumTop += (pfTraversingTemplate[j] * pfTraversedTarget[j]);
<a name="l00456"></a>00456                                        fSumBottom += (pfTraversedTarget[j] * pfTraversedTarget[j]);
<a name="l00457"></a>00457                                     }
<a name="l00458"></a>00458                                  pfTraversedTarget += nWI;  <span class="comment">// move to next row relative to Target</span>
<a name="l00459"></a>00459                                  pfTraversingTemplate += nWT;   <span class="comment">// move to next row in the Template</span>
<a name="l00460"></a>00460                               }
<a name="l00461"></a>00461 
<a name="l00462"></a>00462                            <span class="keywordflow">if</span> (fSumBottom == 0)
<a name="l00463"></a>00463                               <span class="keywordflow">continue</span>;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465                            fCorr = fSumTop / sqrt(fSumBottom);
<a name="l00466"></a>00466                            <span class="keywordflow">if</span> (fCorr &gt; fMax)
<a name="l00467"></a>00467                               {
<a name="l00468"></a>00468                                  fMax = fCorr;
<a name="l00469"></a>00469                                  rnDx = x;
<a name="l00470"></a>00470                                  rnDy = y;
<a name="l00471"></a>00471                               }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473                            <span class="comment">// Also, keep track of the minimum correlation found (for mapping purposes)</span>
<a name="l00474"></a>00474                            <span class="keywordflow">if</span> (fCorr &lt; fMin)
<a name="l00475"></a>00475                               {
<a name="l00476"></a>00476                                  fMin = fCorr;
<a name="l00477"></a>00477                               }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479                            afCorrValues[nCorrCounter] = fCorr; <span class="comment">// Save correlation value of this round</span>
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="comment">//                           std::cout &lt;&lt; nCorrCounter &lt;&lt; &quot;: &quot; &lt;&lt; afCorrValues[nCorrCounter] &lt;&lt; &quot; | &quot;;</span>
<a name="l00482"></a>00482                            nCorrCounter++;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484                         } <span class="comment">//next column</span>
<a name="l00485"></a>00485 <span class="comment">//                     std::cout &lt;&lt; std::endl;</span>
<a name="l00486"></a>00486                   } <span class="comment">//next row</span>
<a name="l00487"></a>00487 
<a name="l00488"></a>00488                <span class="comment">/* update search window or normalize final correlation value */</span>
<a name="l00489"></a>00489                <span class="keywordflow">if</span> (n)
<a name="l00490"></a>00490                   { <span class="comment">// set search window for next pyramid level</span>
<a name="l00491"></a>00491 <span class="comment">//                     xI = MAX(0, 2 * rnDx - n);</span>
<a name="l00492"></a>00492 <span class="comment">//                     yI = MAX(0, 2 * rnDy - n);</span>
<a name="l00493"></a>00493 <span class="comment">//                     nXTraverse = MIN(2 * nWI, 2 * rnDx + n);</span>
<a name="l00494"></a>00494 <span class="comment">//                     nYTraverse = MIN(2 * nHI, 2 * rnDy + n);</span>
<a name="l00495"></a>00495                   }
<a name="l00496"></a>00496                <span class="keywordflow">else</span>
<a name="l00497"></a>00497                   {
<a name="l00498"></a>00498                   <span class="comment">// normalize correlation value at final level</span>
<a name="l00499"></a>00499                   total = nWT * nHT;
<a name="l00500"></a>00500                   <span class="keywordflow">for</span> (i = fTemplatePower = 0; i &lt; total; i++)
<a name="l00501"></a>00501                      fTemplatePower += (pfImgTemplate[i] * pfImgTemplate[i]);
<a name="l00502"></a>00502 
<a name="l00503"></a>00503                   <span class="keywordtype">float</span> fSquareRootOfTemplatePower = sqrt(fTemplatePower);
<a name="l00504"></a>00504                   fCorr = fMax / fSquareRootOfTemplatePower;
<a name="l00505"></a>00505 <span class="comment">//                  std::cout &lt;&lt; &quot;Max: &quot; &lt;&lt; fMax &lt;&lt; &quot;  TemplatePower: &quot; &lt;&lt; fTemplatePower;</span>
<a name="l00506"></a>00506 
<a name="l00507"></a>00507                   <span class="comment">// Normalize fMax and fMin</span>
<a name="l00508"></a>00508                   fMax = fCorr;  <span class="comment">// because it&apos;s already normalized</span>
<a name="l00509"></a>00509                   fMin = fMin / fSquareRootOfTemplatePower;
<a name="l00510"></a>00510 
<a name="l00511"></a>00511                   nCorrCounter = 0; <span class="comment">// Reset nCorrCounter before it starts counting again</span>
<a name="l00512"></a>00512 
<a name="l00513"></a>00513                   <span class="comment">// Normalize all the correlation values stored in the array afCorrValues</span>
<a name="l00514"></a>00514                   <span class="keywordflow">for</span> (y = 0; y &lt;= nYTraverse; y++) <span class="comment">// Traverses the height until the template&apos;s bottom is sitting on the bottom edge of the target</span>
<a name="l00515"></a>00515                      { <span class="comment">// visit rows</span>
<a name="l00516"></a>00516                         <span class="keywordflow">for</span> (x = 0; x &lt;= nXTraverse; x++)    <span class="comment">// Traverses the width until the template&apos;s right edge is on the right edge of the target</span>
<a name="l00517"></a>00517                            { <span class="comment">// visit columns</span>
<a name="l00518"></a>00518                            <span class="comment">// Normalized each correlation value in the array with respect to the sqrt(fTemplatePower)</span>
<a name="l00519"></a>00519                            afCorrValues[nCorrCounter] = afCorrValues[nCorrCounter] / fSquareRootOfTemplatePower;
<a name="l00520"></a>00520 
<a name="l00521"></a>00521                            <span class="comment">// Interpolate values from 0 to 1 between fMin and fMax</span>
<a name="l00522"></a>00522                            <span class="comment">// x_normalized = (x - min) / (max - min)</span>
<a name="l00523"></a>00523                            <span class="keywordflow">if</span>( afCorrValues[nCorrCounter] &lt; 0)
<a name="l00524"></a>00524                               afCorrValues[nCorrCounter] = 0;
<a name="l00525"></a>00525                            <span class="keywordflow">else</span>
<a name="l00526"></a>00526                               afCorrValues[nCorrCounter] = (afCorrValues[nCorrCounter] - fMin) / (fMax - fMin);
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="comment">//                           std::cout &lt;&lt; nCorrCounter &lt;&lt; &quot;: &quot; &lt;&lt; afCorrValues[nCorrCounter] &lt;&lt; &quot; | &quot;;</span>
<a name="l00529"></a>00529 
<a name="l00530"></a>00530                            <span class="comment">// Paint pixel in gray-scale correlation map</span>
<a name="l00531"></a>00531                            nValue = (int)(afCorrValues[nCorrCounter] * 255.0); <span class="comment">// normalized correlation value for a grayscale</span>
<a name="l00532"></a>00532                            m_corrMapImage-&gt;setPixel(x, y, nValue);
<a name="l00533"></a>00533                            nCorrCounter++;
<a name="l00534"></a>00534                            }
<a name="l00535"></a>00535 <span class="comment">//                        std::cout &lt;&lt; std::endl;</span>
<a name="l00536"></a>00536                      }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538                   }
<a name="l00539"></a>00539                <span class="keywordflow">break</span>;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541             <span class="keywordflow">case</span> SUM_SQ_DIFF:
<a name="l00542"></a>00542                <span class="comment">/*  SUM_SQ_DIFF (sum of squared differences):</span>
<a name="l00543"></a>00543 <span class="comment">                *             C(u,v) = sum of {T(x,y)-I(x-u,y-v)}^2</span>
<a name="l00544"></a>00544 <span class="comment">                *                      ------------------------------</span>
<a name="l00545"></a>00545 <span class="comment">                *                      sqrt{ sum of {I(x-u,y-v)^2}}</span>
<a name="l00546"></a>00546 <span class="comment">                *     Levels:</span>
<a name="l00547"></a>00547 <span class="comment">                *             C = 0 Perfect Match</span>
<a name="l00548"></a>00548 <span class="comment">                *             0 &lt; C &lt; 1: Some Match (closer to 0 is higher)</span>
<a name="l00549"></a>00549 <span class="comment">                *             C = 1: No Match</span>
<a name="l00550"></a>00550 <span class="comment">                */</span>
<a name="l00551"></a>00551                <span class="keywordflow">for</span> (y = 0; y &lt;= nYTraverse; y++)  <span class="comment">// Traverses the height until the template&apos;s bottom is sitting on the bottom edge of the target</span>
<a name="l00552"></a>00552                   { <span class="comment">/* visit rows   */</span>
<a name="l00553"></a>00553                      <span class="keywordflow">for</span> (x = 0; x &lt;= nXTraverse; x++) <span class="comment">// Traverses the width until the template&apos;s right edge is on the right edge of the target</span>
<a name="l00554"></a>00554                         { <span class="comment">/* slide window */</span>
<a name="l00555"></a>00555                            fSumTop = fSumBottom = 0;
<a name="l00556"></a>00556 
<a name="l00557"></a>00557                            nPixelNumber = (y * nWI) + x;
<a name="l00558"></a>00558                            pfTraversedTarget = pfImgTarget + nPixelNumber;
<a name="l00559"></a>00559                            pfTraversingTemplate = pfImgTemplate;
<a name="l00560"></a>00560                            <span class="keywordflow">for</span> (i = 0; i &lt; nHT; i++)
<a name="l00561"></a>00561                               { <span class="comment">/* convolution  */</span>
<a name="l00562"></a>00562                                  <span class="keywordflow">for</span> (j = 0; j &lt; nWT; j++)
<a name="l00563"></a>00563                                     {
<a name="l00564"></a>00564                                        fDiff = pfTraversingTemplate[j] - pfTraversedTarget[j];
<a name="l00565"></a>00565                                        fSumTop += (fDiff * fDiff);
<a name="l00566"></a>00566                                        fSumBottom += (pfTraversedTarget[j] * pfTraversedTarget[j]);
<a name="l00567"></a>00567                                     }
<a name="l00568"></a>00568                                  pfTraversedTarget += nWI;
<a name="l00569"></a>00569                                  pfTraversingTemplate += nWT;
<a name="l00570"></a>00570                               }
<a name="l00571"></a>00571                            <span class="keywordflow">if</span> (fSumBottom == 0)
<a name="l00572"></a>00572                               <span class="keywordflow">continue</span>;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574                            fCorr = fSumTop / sqrt(fSumBottom);
<a name="l00575"></a>00575                            <span class="keywordflow">if</span> (fCorr &lt; fMin)
<a name="l00576"></a>00576                               {
<a name="l00577"></a>00577                                  fMin = fCorr;
<a name="l00578"></a>00578                                  rnDx = x;
<a name="l00579"></a>00579                                  rnDy = y;
<a name="l00580"></a>00580                               }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582                             <span class="comment">// Also, keep track of the maximum correlation found (for mapping purposes)</span>
<a name="l00583"></a>00583                             <span class="keywordflow">if</span> (fCorr &gt; fMax)
<a name="l00584"></a>00584                                {
<a name="l00585"></a>00585                                   fMax = fCorr;
<a name="l00586"></a>00586                                }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588                             afCorrValues[nCorrCounter] = fCorr; <span class="comment">// Save correlation value of this round</span>
<a name="l00589"></a>00589                             nCorrCounter++;
<a name="l00590"></a>00590                         } <span class="comment">// next column</span>
<a name="l00591"></a>00591                   } <span class="comment">// next row</span>
<a name="l00592"></a>00592 
<a name="l00593"></a>00593                <span class="comment">/* update search window or normalize final correlation value */</span>
<a name="l00594"></a>00594                <span class="keywordflow">if</span> (n)
<a name="l00595"></a>00595                   { <span class="comment">/* set search window for next pyramid level  */</span>
<a name="l00596"></a>00596 <span class="comment">//                     xI = MAX(0, 2 * rnDx - n);</span>
<a name="l00597"></a>00597 <span class="comment">//                     yI = MAX(0, 2 * rnDy - n);</span>
<a name="l00598"></a>00598 <span class="comment">//                     nXTraverse = MIN(2 * nWI, 2 * rnDx + n);</span>
<a name="l00599"></a>00599 <span class="comment">//                     nYTraverse = MIN(2 * nHI, 2 * rnDy + n);</span>
<a name="l00600"></a>00600                   }
<a name="l00601"></a>00601                <span class="keywordflow">else</span>
<a name="l00602"></a>00602                   { <span class="comment">/* normalize correlation value at final level */</span>
<a name="l00603"></a>00603                      total = nWT * nHT;
<a name="l00604"></a>00604                      <span class="keywordflow">for</span> (i = fTemplatePower = 0; i &lt; total; i++)
<a name="l00605"></a>00605                         fTemplatePower += (pfImgTemplate[i] * pfImgTemplate[i]);
<a name="l00606"></a>00606                      <span class="keywordtype">float</span> fSquareRootOfTemplatePower = sqrt(fTemplatePower);
<a name="l00607"></a>00607                      fCorr = fMin / fSquareRootOfTemplatePower;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 
<a name="l00610"></a>00610                      <span class="comment">// Normalize fMax and fMin</span>
<a name="l00611"></a>00611                      fMin = fCorr;  <span class="comment">// because it&apos;s already normalized</span>
<a name="l00612"></a>00612                      fMax = fMax / sqrt(fTemplatePower);
<a name="l00613"></a>00613 
<a name="l00614"></a>00614                      nCorrCounter = 0; <span class="comment">// Reset nCorrCounter before it starts counting again</span>
<a name="l00615"></a>00615 
<a name="l00616"></a>00616                      <span class="comment">// Normalize all the correlation values stored in the array afCorrValues</span>
<a name="l00617"></a>00617                      <span class="keywordflow">for</span> (y = 0; y &lt;= nYTraverse; y++) <span class="comment">// Traverses the height until the template&apos;s bottom is sitting on the bottom edge of the target</span>
<a name="l00618"></a>00618                         { <span class="comment">// visit rows</span>
<a name="l00619"></a>00619                            <span class="keywordflow">for</span> (x = 0; x &lt;= nXTraverse; x++)    <span class="comment">// Traverses the width until the template&apos;s right edge is on the right edge of the target</span>
<a name="l00620"></a>00620                               { <span class="comment">// visit columns</span>
<a name="l00621"></a>00621                               <span class="comment">// Normalized each correlation value in the array with respect to the sqrt(fTemplatePower)</span>
<a name="l00622"></a>00622                               afCorrValues[nCorrCounter] = afCorrValues[nCorrCounter] / fSquareRootOfTemplatePower;
<a name="l00623"></a>00623 
<a name="l00624"></a>00624                               <span class="comment">// Interpolate values from 0 to 1 between fMin and fMax, where 0 in this case indicates a higher correlation level</span>
<a name="l00625"></a>00625                               <span class="comment">// x_normalized = [(min-x) / (max - min)] + 1</span>
<a name="l00626"></a>00626                               afCorrValues[nCorrCounter] = ((fMin - afCorrValues[nCorrCounter]) / (fMax - fMin)) + 1;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 <span class="comment">//                              std::cout &lt;&lt; nCorrCounter &lt;&lt; &quot;: &quot; &lt;&lt; afCorrValues[nCorrCounter] &lt;&lt; &quot; | &quot;;</span>
<a name="l00629"></a>00629 
<a name="l00630"></a>00630                               <span class="comment">// Paint pixel in gray-scale correlation map</span>
<a name="l00631"></a>00631                               nValue = (int)(afCorrValues[nCorrCounter] * 255.0); <span class="comment">// normalized correlation value for a grayscale</span>
<a name="l00632"></a>00632                               m_corrMapImage-&gt;setPixel(x, y, nValue);
<a name="l00633"></a>00633                               nCorrCounter++;
<a name="l00634"></a>00634                               }
<a name="l00635"></a>00635 <span class="comment">//                           std::cout &lt;&lt; std::endl;</span>
<a name="l00636"></a>00636                         }
<a name="l00637"></a>00637                   }
<a name="l00638"></a>00638                <span class="keywordflow">break</span>;
<a name="l00639"></a>00639 
<a name="l00640"></a>00640             <span class="keywordflow">case</span> CORR_COEFF:
<a name="l00641"></a>00641                <span class="comment">/* CORR_COEFF (correlation coefficient):</span>
<a name="l00642"></a>00642 <span class="comment">                *             C(u,v) = sum of {(T(x,y)-Tavg) * (I(x-u,y-v)-Iavg)}</span>
<a name="l00643"></a>00643 <span class="comment">                *                      -----------------------------------------------------</span>
<a name="l00644"></a>00644 <span class="comment">                *                      sqrt{sum{(T(x,y)-Tavg)^2} * sum{(I(x-u,y-v)-Iavg)^2}}</span>
<a name="l00645"></a>00645 <span class="comment">                *     Levels:</span>
<a name="l00646"></a>00646 <span class="comment">                *             C = 1 Perfect Match</span>
<a name="l00647"></a>00647 <span class="comment">                *             C = 0: No Match</span>
<a name="l00648"></a>00648 <span class="comment">                *             0 &lt; C &lt; 1: Some Match (closer to 1 is better)</span>
<a name="l00649"></a>00649 <span class="comment">                *             -1 &lt; C &lt; 0: Mismatch</span>
<a name="l00650"></a>00650 <span class="comment">                */</span>
<a name="l00651"></a>00651 
<a name="l00652"></a>00652                 <span class="comment">/* compute pfTraversingTemplate average */</span>
<a name="l00653"></a>00653                total = nWT * nHT;
<a name="l00654"></a>00654                <span class="keywordflow">for</span> (i = fAverage = 0; i &lt; total; i++)
<a name="l00655"></a>00655                   fAverage += pfImgTemplate[i];
<a name="l00656"></a>00656                fAverage /= total;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658                <span class="comment">/* subtract average from template */</span>
<a name="l00659"></a>00659                <span class="keywordflow">for</span> (i = 0; i &lt; total; i++)
<a name="l00660"></a>00660                   pfImgTemplate[i] -= fAverage;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662                <span class="comment">/* compute template power */</span>
<a name="l00663"></a>00663                <span class="keywordflow">for</span> (i = fTemplatePower = 0; i &lt; total; i++)
<a name="l00664"></a>00664                   fTemplatePower += (pfImgTemplate[i] * pfImgTemplate[i]);
<a name="l00665"></a>00665 
<a name="l00666"></a>00666                <span class="comment">// CARLOS: this following averaging process of the Target Image is done next in a similar way as with the template</span>
<a name="l00667"></a>00667 <span class="comment">//               /* compute local pfTraversedTarget average: blur with box filter */</span>
<a name="l00668"></a>00668 <span class="comment">//               dXSize = nWT + !(nWT % 2); /* make filter width  odd */</span>
<a name="l00669"></a>00669 <span class="comment">//               dYSize = nHT + !(nHT % 2); /* make filter height odd */</span>
<a name="l00670"></a>00670 <span class="comment">//               IP_blur(pyramidTarget[n], dXSize, dYSize, Iblur = NEWIMAGE);</span>
<a name="l00671"></a>00671 <span class="comment">//</span>
<a name="l00672"></a>00672 <span class="comment">//               /* subtract local pfTraversedTarget averages from pixels */</span>
<a name="l00673"></a>00673 <span class="comment">//               IP_subtractImage(pyramidTarget[n], Iblur, pyramidTarget[n]);</span>
<a name="l00674"></a>00674 <span class="comment">//               IP_freeImage(Iblur);</span>
<a name="l00675"></a>00675 
<a name="l00676"></a>00676                <span class="comment">// compute average on the entire traversed target image</span>
<a name="l00677"></a>00677                <span class="comment">//     Not sure if the average has to be taken from the whole image (or the traversed window)</span>
<a name="l00678"></a>00678                total = nWI * nHI;
<a name="l00679"></a>00679                <span class="keywordflow">for</span> (i = fAverage = 0; i &lt; total; i++)  <span class="comment">// total is the same for both templates and target samples</span>
<a name="l00680"></a>00680                   fAverage += pfImgTarget[i];
<a name="l00681"></a>00681 
<a name="l00682"></a>00682                fAverage /= total;
<a name="l00683"></a>00683 
<a name="l00684"></a>00684                <span class="comment">// subtract average on the traversed target image segment</span>
<a name="l00685"></a>00685                <span class="keywordflow">for</span> (i = 0; i &lt; total; i++)
<a name="l00686"></a>00686                   pfImgTarget[i] -= fAverage;
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 
<a name="l00689"></a>00689                <span class="keywordflow">for</span> (y = 0; y &lt;= nYTraverse; y++)
<a name="l00690"></a>00690                   { <span class="comment">/* visit rows   */</span>
<a name="l00691"></a>00691                   <span class="keywordflow">for</span> (x = 0; x &lt;= nXTraverse; x++)
<a name="l00692"></a>00692                      { <span class="comment">/* slide window */</span>
<a name="l00693"></a>00693 
<a name="l00694"></a>00694                      fSumTop = fSumBottom = fTargetPower = 0;  <span class="comment">// Reset sums</span>
<a name="l00695"></a>00695                      pfTraversedTarget = pfImgTarget + (y * nWI) + x;<span class="comment">/* avgs  were  subtracted  */</span>
<a name="l00696"></a>00696                      pfTraversingTemplate = pfImgTemplate; <span class="comment">/* from pfTraversedTarget and pfTraversingTemplate */</span>
<a name="l00697"></a>00697 
<a name="l00698"></a>00698                      <span class="comment">// compute average on the window of the traversed target image</span>
<a name="l00699"></a>00699                      <span class="comment">// which is wrong because it must be the average of the whole image,</span>
<a name="l00700"></a>00700                      <span class="comment">// so the following it&apos;s commented out!</span>
<a name="l00701"></a>00701 <span class="comment">//                     for (i = fAverage = 0; i &lt; total; i++)  // total is the same for both templates and target samples</span>
<a name="l00702"></a>00702 <span class="comment">//                        fAverage += pfTraversedTarget[i];</span>
<a name="l00703"></a>00703 <span class="comment">//</span>
<a name="l00704"></a>00704 <span class="comment">//                     fAverage /= total;</span>
<a name="l00705"></a>00705 <span class="comment">//</span>
<a name="l00706"></a>00706 <span class="comment">//                     // subtract average on the traversed target image segment</span>
<a name="l00707"></a>00707 <span class="comment">//                     for (i = 0; i &lt; total; i++)</span>
<a name="l00708"></a>00708 <span class="comment">//                        pfTraversedTarget[i] -= fAverage;</span>
<a name="l00709"></a>00709 
<a name="l00710"></a>00710                      <span class="keywordflow">for</span> (i = 0; i &lt; nHT; i++)
<a name="l00711"></a>00711                         { <span class="comment">/* convolution  */</span>
<a name="l00712"></a>00712                         <span class="keywordflow">for</span> (j = 0; j &lt; nWT; j++)
<a name="l00713"></a>00713                            {
<a name="l00714"></a>00714                            fSumTop += (pfTraversingTemplate[j] * pfTraversedTarget[j]);
<a name="l00715"></a>00715                            fTargetPower += (pfTraversedTarget[j] * pfTraversedTarget[j]);
<a name="l00716"></a>00716                            }
<a name="l00717"></a>00717                         pfTraversedTarget += nWI;
<a name="l00718"></a>00718                         pfTraversingTemplate += nWT;
<a name="l00719"></a>00719                         }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721                      fSumBottom = fTargetPower * fTemplatePower;
<a name="l00722"></a>00722                      fCorr = fSumTop / sqrt(fSumBottom);
<a name="l00723"></a>00723                      <span class="keywordflow">if</span> (fCorr &gt; fMax)
<a name="l00724"></a>00724                         {
<a name="l00725"></a>00725                         fMax = fCorr;
<a name="l00726"></a>00726                         rnDx = x;
<a name="l00727"></a>00727                         rnDy = y;
<a name="l00728"></a>00728                         }
<a name="l00729"></a>00729                      <span class="comment">// Also, keep track of the minimum correlation found (for mapping purposes)</span>
<a name="l00730"></a>00730                      <span class="keywordflow">if</span> (fCorr &lt; fMin)
<a name="l00731"></a>00731                         {
<a name="l00732"></a>00732                            fMin = fCorr;
<a name="l00733"></a>00733                         }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735                      afCorrValues[nCorrCounter] = fCorr; <span class="comment">// Save correlation value of this round</span>
<a name="l00736"></a>00736                      nCorrCounter++;
<a name="l00737"></a>00737                      } <span class="comment">// next column</span>
<a name="l00738"></a>00738                   } <span class="comment">// next row</span>
<a name="l00739"></a>00739 
<a name="l00740"></a>00740                <span class="comment">/* update search window or set final correlation value */</span>
<a name="l00741"></a>00741                <span class="keywordflow">if</span> (n)
<a name="l00742"></a>00742                   { <span class="comment">/* set search window for next pyramid level */</span>
<a name="l00743"></a>00743 <span class="comment">//                  xI = MAX(0, 2 * rnDx - n);</span>
<a name="l00744"></a>00744 <span class="comment">//                  yI = MAX(0, 2 * rnDy - n);</span>
<a name="l00745"></a>00745 <span class="comment">//                  nXTraverse = MIN(2 * nWI, 2 * rnDx + n);</span>
<a name="l00746"></a>00746 <span class="comment">//                  nYTraverse = MIN(2 * nHI, 2 * rnDy + n);</span>
<a name="l00747"></a>00747                   }
<a name="l00748"></a>00748                <span class="keywordflow">else</span>
<a name="l00749"></a>00749                   { <span class="comment">/* set correlation value at final level */</span>
<a name="l00750"></a>00750                   fCorr = fMax;
<a name="l00751"></a>00751 
<a name="l00752"></a>00752                   nCorrCounter = 0; <span class="comment">// Reset nCorrCounter before it starts counting again</span>
<a name="l00753"></a>00753 
<a name="l00754"></a>00754                   <span class="comment">// The correlation values stored in the array afCorrValues are already normalized</span>
<a name="l00755"></a>00755                   <span class="comment">// there is no need to divide by the square root of the powers</span>
<a name="l00756"></a>00756                   <span class="keywordflow">for</span> (y = 0; y &lt;= nYTraverse; y++) <span class="comment">// Traverses the height until the template&apos;s bottom is sitting on the bottom edge of the target</span>
<a name="l00757"></a>00757                      { <span class="comment">// visit rows</span>
<a name="l00758"></a>00758                         <span class="keywordflow">for</span> (x = 0; x &lt;= nXTraverse; x++)    <span class="comment">// Traverses the width until the template&apos;s right edge is on the right edge of the target</span>
<a name="l00759"></a>00759                            { <span class="comment">// visit columns</span>
<a name="l00760"></a>00760                            <span class="comment">// Interpolate values from 0 to 1 between fMin and fMax</span>
<a name="l00761"></a>00761                            <span class="comment">// x_normalized = (x - min) / (max - min)</span>
<a name="l00762"></a>00762                            <span class="keywordflow">if</span>(afCorrValues[nCorrCounter] &lt;= 0.0)
<a name="l00763"></a>00763                               afCorrValues[nCorrCounter] = 0.0;  <span class="comment">// Lowest normalized value. There is no correlation match</span>
<a name="l00764"></a>00764                            <span class="comment">// All other values are already normalized between 0 and 1</span>
<a name="l00765"></a>00765                            <span class="comment">// Just interpolate them:</span>
<a name="l00766"></a>00766                            <span class="keywordflow">else</span>
<a name="l00767"></a>00767                               afCorrValues[nCorrCounter] = (afCorrValues[nCorrCounter] - fMin) / (fMax - fMin);
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 <span class="comment">//                           std::cout &lt;&lt; nCorrCounter &lt;&lt; &quot;: &quot; &lt;&lt; afCorrValues[nCorrCounter] &lt;&lt; &quot; | &quot;;</span>
<a name="l00770"></a>00770 
<a name="l00771"></a>00771                            <span class="comment">// Paint pixel in gray-scale correlation map</span>
<a name="l00772"></a>00772                            nValue = (int)(afCorrValues[nCorrCounter] * 255.0); <span class="comment">// normalized correlation value for a grayscale</span>
<a name="l00773"></a>00773                            m_corrMapImage-&gt;setPixel(x, y, nValue);
<a name="l00774"></a>00774                            nCorrCounter++;
<a name="l00775"></a>00775                            }
<a name="l00776"></a>00776 <span class="comment">//                        std::cout &lt;&lt; std::endl;</span>
<a name="l00777"></a>00777                      }
<a name="l00778"></a>00778                   }
<a name="l00779"></a>00779                <span class="keywordflow">break</span>;
<a name="l00780"></a>00780 <span class="comment">//</span>
<a name="l00781"></a>00781 <span class="comment">//            case PHASE_CORR: /* Fourier phase correlation */</span>
<a name="l00782"></a>00782 <span class="comment">//               IP_crop(I2, 0, 0, nWI, nHI, II2); /* pad template      */</span>
<a name="l00783"></a>00783 <span class="comment">//               IP_fft2D(II1, 1, Ifft1 = NEWIMAGE); /* pfTraversedTarget    FFT (F1) */</span>
<a name="l00784"></a>00784 <span class="comment">//               IP_fft2D(II2, 1, Ifft2 = NEWIMAGE); /* template FFT (F2) */</span>
<a name="l00785"></a>00785 <span class="comment">//               IP_complexConjugate(Ifft2, Ifft2); /* F2* is cmplx conj */</span>
<a name="l00786"></a>00786 <span class="comment">//               IP_multiplyCmplx(Ifft1, Ifft2, Ifft1); /* F1 x F2*      */</span>
<a name="l00787"></a>00787 <span class="comment">//</span>
<a name="l00788"></a>00788 <span class="comment">//               /* divide F1 x F2* by the magnitude of (F1 x F2*) */</span>
<a name="l00789"></a>00789 <span class="comment">//               total = nWI * nHI;</span>
<a name="l00790"></a>00790 <span class="comment">//               pfImgTarget = (float *) Ifft1-&gt;buf[0];</span>
<a name="l00791"></a>00791 <span class="comment">//               pfImgTemplate = (float *) Ifft1-&gt;buf[1];</span>
<a name="l00792"></a>00792 <span class="comment">//               for (i = 0; i &lt; total; i++)</span>
<a name="l00793"></a>00793 <span class="comment">//                  {</span>
<a name="l00794"></a>00794 <span class="comment">//                     mag = MAG(*pfImgTarget, *pfImgTemplate);</span>
<a name="l00795"></a>00795 <span class="comment">//                     *pfImgTarget++ /= mag;</span>
<a name="l00796"></a>00796 <span class="comment">//                     *pfImgTemplate++ /= mag;</span>
<a name="l00797"></a>00797 <span class="comment">//                  }</span>
<a name="l00798"></a>00798 <span class="comment">//</span>
<a name="l00799"></a>00799 <span class="comment">//               /* find position of maximum in inverse FFT */</span>
<a name="l00800"></a>00800 <span class="comment">//               IP_fft2D(Ifft1, -1, Ifft2);</span>
<a name="l00801"></a>00801 <span class="comment">//               pfImgTarget = (float *) Ifft2-&gt;buf[0];</span>
<a name="l00802"></a>00802 <span class="comment">//               pfImgTemplate = (float *) Ifft2-&gt;buf[1];</span>
<a name="l00803"></a>00803 <span class="comment">//               for (y = 0; y &lt; nHI; y++)</span>
<a name="l00804"></a>00804 <span class="comment">//                  {</span>
<a name="l00805"></a>00805 <span class="comment">//                     for (x = 0; x &lt; nWI; x++)</span>
<a name="l00806"></a>00806 <span class="comment">//                        {</span>
<a name="l00807"></a>00807 <span class="comment">//                           mag = MAG(*pfImgTarget, *pfImgTemplate);</span>
<a name="l00808"></a>00808 <span class="comment">//                           if (mag &gt; fMax)</span>
<a name="l00809"></a>00809 <span class="comment">//                              {</span>
<a name="l00810"></a>00810 <span class="comment">//                                 fMax = mag;</span>
<a name="l00811"></a>00811 <span class="comment">//                                 rnDx = x;</span>
<a name="l00812"></a>00812 <span class="comment">//                                 rnDy = y;</span>
<a name="l00813"></a>00813 <span class="comment">//                              }</span>
<a name="l00814"></a>00814 <span class="comment">//                           pfImgTarget++;</span>
<a name="l00815"></a>00815 <span class="comment">//                           pfImgTemplate++;</span>
<a name="l00816"></a>00816 <span class="comment">//                        }</span>
<a name="l00817"></a>00817 <span class="comment">//                  }</span>
<a name="l00818"></a>00818 <span class="comment">//               IP_freeImage(Ifft1);</span>
<a name="l00819"></a>00819 <span class="comment">//               IP_freeImage(Ifft2);</span>
<a name="l00820"></a>00820 <span class="comment">//</span>
<a name="l00821"></a>00821 <span class="comment">//               /* update position to avoid wrap-around; allow for -rnDx or -rnDy */</span>
<a name="l00822"></a>00822 <span class="comment">//               if (rnDx &gt; nWI / 2)</span>
<a name="l00823"></a>00823 <span class="comment">//                  rnDx -= nWI;</span>
<a name="l00824"></a>00824 <span class="comment">//               if (rnDy &gt; nHI / 2)</span>
<a name="l00825"></a>00825 <span class="comment">//                  rnDy -= nHI;</span>
<a name="l00826"></a>00826 <span class="comment">//               fCorr = mag;</span>
<a name="l00827"></a>00827 <span class="comment">//               break;</span>
<a name="l00828"></a>00828 
<a name="l00829"></a>00829             <span class="keywordflow">default</span>:
<a name="l00830"></a>00830                QMessageBox::warning(<span class="keyword">this</span>, tr(<span class="stringliteral">&quot;QCorr:&quot;</span>), tr(<span class="stringliteral">&quot;Bad nMethod %1\n&quot;</span>).arg(nMethod));
<a name="l00831"></a>00831                <span class="keywordflow">return</span> 0.;
<a name="l00832"></a>00832             }
<a name="l00833"></a>00833       }
<a name="l00834"></a>00834    <span class="comment">// CARLOS: needs review from up to this point on...^^^^^^^^^^^^^^^^^^</span>
<a name="l00835"></a>00835 
<a name="l00836"></a>00836 <span class="comment">//   /* free images */</span>
<a name="l00837"></a>00837 <span class="comment">//   if (I1 != II1)</span>
<a name="l00838"></a>00838 <span class="comment">//      IP_freeImage(II1);</span>
<a name="l00839"></a>00839 <span class="comment">//   if (I2 != II2)</span>
<a name="l00840"></a>00840 <span class="comment">//      IP_freeImage(II2);</span>
<a name="l00841"></a>00841 <span class="comment">//   for (n = 1; n &lt;= mxlevel; n++)</span>
<a name="l00842"></a>00842 <span class="comment">//      {</span>
<a name="l00843"></a>00843 <span class="comment">//         IP_freeImage(pyramidTarget[n]);</span>
<a name="l00844"></a>00844 <span class="comment">//         IP_freeImage(pyramidTemplate[n]);</span>
<a name="l00845"></a>00845 <span class="comment">//      }</span>
<a name="l00846"></a>00846 
<a name="l00847"></a>00847 <span class="comment">//   *xx = rnDx;</span>
<a name="l00848"></a>00848 <span class="comment">//   *yy = rnDy;</span>
<a name="l00849"></a>00849 
<a name="l00850"></a>00850    QApplication::restoreOverrideCursor();
<a name="l00851"></a>00851 
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 <span class="comment">// Deallocate arrays from memory</span>
<a name="l00854"></a>00854    <span class="keyword">delete</span> [] afImgTarget;
<a name="l00855"></a>00855    <span class="keyword">delete</span> [] afImgTemplate;
<a name="l00856"></a>00856    <span class="keyword">delete</span> [] afCorrValues;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858    <span class="keywordflow">return</span> fCorr;
<a name="l00859"></a>00859 <span class="comment">//   return fMax;</span>
<a name="l00860"></a>00860 }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 <span class="keywordtype">void</span> Qcorr::displayImage(QImage *image, QLabel *label)
<a name="l00863"></a>00863 {
<a name="l00864"></a>00864    label-&gt;setPixmap(QPixmap::fromImage(*image));
<a name="l00865"></a>00865    label-&gt;adjustSize();
<a name="l00866"></a>00866 }
<a name="l00867"></a>00867 
<a name="l00868"></a>00868 <span class="keywordtype">void</span> Qcorr::displayImageLabel(QImage *image, <a class="code" href="classImgLabel.html">ImgLabel</a> *label)
<a name="l00869"></a>00869 {
<a name="l00870"></a>00870    label-&gt;setPixmap(QPixmap::fromImage(*image));
<a name="l00871"></a>00871    label-&gt;adjustSize();
<a name="l00872"></a>00872    <span class="comment">// m_labelLowerRightCornerPoint must be set here (in the parent) because the label size can change dynamically</span>
<a name="l00873"></a>00873    label-&gt;m_labelLowerRightCornerPoint = QPoint(label-&gt;width(), label-&gt;height());
<a name="l00874"></a>00874 }
<a name="l00875"></a>00875 
<a name="l00876"></a><a class="code" href="classQcorr.html#ad1b26ace597c0c4a0f64a0bd9576d4fc">00876</a> <span class="keywordtype">float</span> * <a class="code" href="classQcorr.html#ad1b26ace597c0c4a0f64a0bd9576d4fc" title="Cast images to an 8-bit gray-scale channel of type float.">Qcorr::convertToGrayScaleFloat</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * pchImgOriginalBits, <span class="keywordtype">int</span> nSize, <span class="keywordtype">int</span> nDepth )
<a name="l00877"></a>00877 {
<a name="l00878"></a>00878    <span class="keywordtype">float</span> * afImgGrayBits = <span class="keyword">new</span> <span class="keywordtype">float</span>[nSize];
<a name="l00879"></a>00879    <span class="keywordtype">float</span> grayValue = 0.0;
<a name="l00880"></a>00880    <span class="keywordtype">int</span> offsetBytes, pixNumber;
<a name="l00881"></a>00881 
<a name="l00882"></a>00882    <span class="keywordflow">switch</span> (nDepth) {
<a name="l00883"></a>00883       <span class="keywordflow">case</span> 32: <span class="comment">// ARGB image (alpha and color channels)</span>
<a name="l00884"></a>00884          offsetBytes = nDepth / 8;
<a name="l00885"></a>00885          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i =0; i&lt;nSize; i++)
<a name="l00886"></a>00886             {
<a name="l00887"></a>00887             pixNumber = i*offsetBytes;
<a name="l00888"></a>00888             grayValue = pchImgOriginalBits[pixNumber + 1] * 0.30;  <span class="comment">// Red value</span>
<a name="l00889"></a>00889             grayValue += pchImgOriginalBits[pixNumber + 2] * 0.59;  <span class="comment">// Green value</span>
<a name="l00890"></a>00890             grayValue += pchImgOriginalBits[pixNumber + 3] * 0.11; <span class="comment">// Blue value</span>
<a name="l00891"></a>00891             afImgGrayBits[i] = grayValue;
<a name="l00892"></a>00892             }
<a name="l00893"></a>00893          <span class="keywordflow">break</span>;
<a name="l00894"></a>00894       <span class="keywordflow">case</span> 24: <span class="comment">// RGB image (3 color channels only)</span>
<a name="l00895"></a>00895          offsetBytes = nDepth / 8;
<a name="l00896"></a>00896          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i =0; i&lt;nSize; i++)
<a name="l00897"></a>00897             {
<a name="l00898"></a>00898             pixNumber = i*offsetBytes;
<a name="l00899"></a>00899             grayValue = pchImgOriginalBits[pixNumber] * 0.30;  <span class="comment">// Red value</span>
<a name="l00900"></a>00900             grayValue += pchImgOriginalBits[pixNumber + 1] * 0.59;  <span class="comment">// Green value</span>
<a name="l00901"></a>00901             grayValue += pchImgOriginalBits[pixNumber + 2] * 0.11; <span class="comment">// Blue value</span>
<a name="l00902"></a>00902             afImgGrayBits[i] = grayValue;
<a name="l00903"></a>00903             }
<a name="l00904"></a>00904          <span class="keywordflow">break</span>;
<a name="l00905"></a>00905       <span class="keywordflow">default</span>:
<a name="l00906"></a>00906          <span class="comment">// 1-bit monochrome and 8-bit grayscale images</span>
<a name="l00907"></a>00907          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i =0; i&lt;nSize; i++)
<a name="l00908"></a>00908             {
<a name="l00909"></a>00909             afImgGrayBits[i] = (float) pchImgOriginalBits[i];
<a name="l00910"></a>00910             }
<a name="l00911"></a>00911          <span class="keywordflow">break</span>;
<a name="l00912"></a>00912    }
<a name="l00913"></a>00913 
<a name="l00914"></a>00914 
<a name="l00915"></a>00915    <span class="keywordflow">return</span> afImgGrayBits;
<a name="l00916"></a>00916 }
<a name="l00917"></a>00917 
<a name="l00918"></a>00918 <span class="comment">// Temp:</span>
<a name="l00919"></a>00919 <span class="keywordtype">bool</span> Qcorr::fileDumpQImage(<span class="keyword">const</span> QString &amp;fileName)
<a name="l00920"></a>00920 {
<a name="l00921"></a>00921    QFile file(fileName);
<a name="l00922"></a>00922    <span class="keywordflow">if</span> (!file.open(QIODevice::WriteOnly)) {
<a name="l00923"></a>00923       QMessageBox::warning(<span class="keyword">this</span>, tr(<span class="stringliteral">&quot;QCorr Image&quot;</span>),
<a name="l00924"></a>00924             tr(<span class="stringliteral">&quot;Cannot write file %1:\n%2.&quot;</span>)
<a name="l00925"></a>00925             .arg(file.fileName())
<a name="l00926"></a>00926             .arg(file.errorString()));
<a name="l00927"></a>00927       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00928"></a>00928    }
<a name="l00929"></a>00929    QDataStream out(&amp;file);
<a name="l00930"></a>00930    out.setVersion(QDataStream::Qt_4_5);
<a name="l00931"></a>00931 
<a name="l00932"></a>00932    QApplication::setOverrideCursor(Qt::WaitCursor);
<a name="l00933"></a>00933 
<a name="l00934"></a>00934    <span class="comment">// Helped to test that the bits dumped by QImage&apos;s bits() function</span>
<a name="l00935"></a>00935    <span class="comment">// is the actual data (pixels) of the image without any header.</span>
<a name="l00936"></a>00936    <span class="comment">// ...just pure pixel data!</span>
<a name="l00937"></a>00937    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * imgTarget = m_rightImage-&gt;bits();
<a name="l00938"></a>00938 
<a name="l00939"></a>00939    <span class="keywordtype">int</span> mysalt = 0;  <span class="comment">// just to see if the image has extra bytes that might be missing</span>
<a name="l00940"></a>00940    <span class="keywordtype">int</span> imgBytes = m_rightImage-&gt;numBytes() + mysalt;
<a name="l00941"></a>00941 
<a name="l00942"></a>00942    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> byteN = 0; byteN &lt; imgBytes; ++byteN) {
<a name="l00943"></a>00943       out &lt;&lt; quint8(imgTarget[byteN]);
<a name="l00944"></a>00944    }
<a name="l00945"></a>00945    QApplication::restoreOverrideCursor();
<a name="l00946"></a>00946    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00947"></a>00947 }
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Nov 27 19:37:43 2009 for Qcorr: A Digital Image Correlation Program implemented in QT4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
